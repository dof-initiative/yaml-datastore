![Bart Simpson in front of chalkboard writing repeatedly "GIT IS NOT A DATABASE"](./bartsimpsonmeme.png)
<br>
**Git is not a database.—but what if it was?** With YAML datastore, you can make your data Git-friendly. 

YAML Datastore is a lightweight library that stores and manages data with structured plaintext files and YAML syntax, designed for use with version control systems. This enables you to gain the advantages of Git for your data—track changes at the feature level, store data across multiple systems, and merge data seamlessly. 
<br>

**Getting Started**

* New to YAML Data Store? Get [introduced](#introduction)
* Ready to install? Follow the [installation steps](#installation)
* Want to learn how YAML Datastore stores information based on data types? Read the [Overview](#overview) section
* Curious about use cases? Read about the [CRUD Operations](#crud-operations)
* Want to use the API? See [the API documentation](#api-v000)

<br>


**Contents** 

!toc (numbered)

# Introduction

## What is YAML Datastore?
YAML Datastore is a lightweight Typescript library designed for observable, human-readable data storage and retrieval using YAML files. It serves as an alternative to traditional databases that do not store data in a version control-friendly way.

## Purpose of YAML Datastore
YAML Datastore exists because we rather than try to add Git-like features to how we store and manage data, we want to do data management in a way that fits in Git. We found that existing systems attempting to use Git as a backend didn't account properly for structure. YAML Datastore automatically manages this structure with easy to understand rules that we explain in the Usage section. 

# Installation
Install the library in the root directory of your project using npm or yarn.

  `npm install yaml-datastore` 

  `yarn add yaml-datastore` 

# Overview
This section provides comprehensive details about how the YAML Datastore library organizes and stores data on disk.

YAML Datastore implements the standard CRUD operations for transforming in-memory objects and lists into structured YAML files and back. We will describe the supported data types, how they map onto the file system, and provide a comprehensive list of example use cases. 

## Supported Data Types
YAML Datastore supports any data types that are supported in YAML (and JSON). YAML Datastore categorizes these data types as simple or complex based upon their representation inside of a YAML file containing that data before serialization. The element that this YAML file represents is referred to as the root element. A root element can either be an object (root object) or a list (root list). 

Simple data types can be represented as a single line in a YAML file. This includes all scalar types; scalar types in YAML are strings without newlines, numbers, booleans, or nulls. Empty lists and empty objects are also simple data types. 

Complex data types require more than one line to be represented as a YAML file. This includes multi-line strings and (non-empty) lists and objects. Complex data types are serialized into individual files. Lists and objects may have child elements that are simple or complex data types. How parent lists and objects reference complex data types will be covered in [Mapping Complex Data Types to Files](#mapping-complex-data-types-to-files).

| Simple Data Types  | Complex Data Types |
| ------------------ | ------------------ |
| String w/o Newline: `"Hello World"`  |  Multi-line String |
| Number: `3.14`, `42`  | List |
| Boolean: `true`, `false` | Object|
| Null: `null` | |
| Empty String: `''` | |
| Empty List: `[]` | |
| Empty Object: `{}` | |

## Mapping Complex Data Types to Files
This section describes each of the complex data types and the method used to serialize them to disk. 

### Multi-line Strings
Multi-line strings are serialized to disk as text files. Multi-line strings will either have an object or list as a parent. For objects, the text files are a sibling of the parent element's `_this.yaml` file. For lists, the text files are a sibling of the parent element's yaml file. The parent file [references](#references-to-subfiles) such files using a convention described in the next section. 

### Lists
Lists are serialized to disk as yaml files. A root list file  lives directly in the working directory. If list is the child of a parent list or object, the list will require its own file which will be [referenced](#references-to-subfiles) in the parent using a convention described in the next section. If the parent is an object, the list will be named after the key*. If the parent is a list, list elements require unique names which are generated using a process described in [List Element IDs](#list-element-ids).

* If key name includes an underscore `_`, this will be changed to a dot separator `.`.  

### Objects
Objects are serialized to disk with a directory and a file `_this.yaml` containing the information. The root object's directory and file contents lives in the working directory. If the object is a child of a parent list or object, the object will require its own directory containing its own `_this.yaml` file, and the parent will [reference](#references-to-subfiles) the object using the convention described in the next section. When the object is the child of an object, the directory is nested in its parent object's directory and be named after the key*. When the object is the child of a list, the object's directory will require a unique name which is generated using a process described in [List Element IDs](#list-element-ids).

## References to Subfiles
To point to the files storing complex data, we use the convention of enclosing the relative filepath in double parentheses `((` `))`. For objects, any underscores `_` are replaced with dot separator `.`. For example `stringname_txt` becomes `((stringname.txt))`. 

## List Element IDs
To properly handle the multiple files and directories representing lists, we need these files and directories to be named using unique, but deterministic IDs.

This datastore uses an Xorshift Random Number Generator (RNG), configured with a seed, that provides gives everyone who uses the datastore the same sequence of "random" numbers every time. 

# CRUD Operations
First we will discuss how each CRUD operation maps onto the library functions, then we will discuss use cases by function.

* Create 
  * Store
* Read 
  * Load
* Update  
  * TBD
* Delete
  * Delete
  * Clear

## Store Use Cases

This section provides an explanation for each identified use case in the YAML Datastore specification. For each use case we provide an example data structure along with its representation on disk and an explanation of why that is the representation. All of these use cases are of a element (an object or a list) named model.

TODO: wordsmith above

!include(test/spec/1.1_object_with_simple_data_types/README.md)

!include(test/spec/1.2.1_object_with_complex_string/README.md)

!include(test/spec/1.2.2_object_with_object_of_simple_data_types/README.md)

!include(test/spec/1.2.3_object_with_object_of_complex_data_types/README.md)

!include(test/spec/1.2.4_object_with_list_of_simple_data_type/README.md)

!include(test/spec/1.2.5_object_with_list_of_simple_data_types/README.md)

!include(test/spec/1.2.6_object_with_list_of_complex_strings/README.md)

!include(test/spec/1.2.7.1_object_with_list_of_objects_of_simple_data_types/README.md)

!include(test/spec/1.2.7.2_object_with_list_of_list_of_simple_data_type/README.md)

!include(docs/README.md)

# License
Mach30/yaml-datastore is licensed under the [Apache 2.0 License](https://github.com/Mach30/yaml-datastore/blob/main/LICENSE).

# Contributions
Include information about developer documentation, contribution policy and community chat boards
